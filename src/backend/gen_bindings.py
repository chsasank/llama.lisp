#!/bin/python3

import re
import sys
import subprocess
import tempfile
import json
import shutil
from llvmlite import binding

## gen_bindings.py
## Provides macros to include forward
## declarations from C header files


class BindingGenError(Exception):
    pass


# Used as a prefix to global variables created for binding generation
VAR_PREFIX = "_bindingGen_"


class BindingGenerator:
    def __init__(self, headers, functions, structs, typedefs, debug, macro_ns):
        # List of headers to be included
        self.headers = headers
        # List of desired function prototypes
        self.functions = functions
        # Mapping of desired struct name -> struct definition
        self.structs = structs
        # List of desired typedefs
        self.typedefs = typedefs

        # The LLVM module containing the signatures we want
        self.llmod = None
        # The AST of the C program generated by Clang
        self.c_ast = None

        # Toggle for debug behaviour
        self.debug = debug

        # Macro namespace
        self.macro_ns = macro_ns

    def gen_cprog(self):
        """Generate the C program for binding generation"""

        ## C code to produce external side-effects
        # Functions
        function_pins = "\n".join(
            f"    pin_function({func});" for func in self.functions
        )
        # Structs
        struct_pins = "\n".join(
            f"    {{ struct {struct} var; pin_function(&var); }}"
            for struct in self.structs
        )
        # Typedefs
        typedef_pins = "\n".join(
            f"{alias} {VAR_PREFIX}{alias};" for alias in self.typedefs
        )

        ## Header inclusion
        header_includes = "\n".join(f'#include "{header}"' for header in self.headers)

        return "\n".join(
            (
                header_includes,
                typedef_pins,
                "extern void pin_function(void *);",
                "int main () {",
                function_pins,
                struct_pins,
                "}",
            )
        )

    def get_clisp_type(self, typ):
        """Map an LLVM type (TypeRef) to a C-Lisp type"""

        ## Handlers for each type kind
        ## Each takes a string as an argument
        def get_clisp_int_type(typ):
            """'iXX' -> 'intXX'"""
            width = typ[1:]
            if width == "32":
                width = ""
            return f"int{width}"

        def get_clisp_ptr_type(typ):
            """'XX*' -> ['ptr', 'XX']"""
            pointee = typ[:-1]
            return ["ptr", self.get_clisp_type(pointee)]

        def get_clisp_struct_type(typ):
            """'%struct.XX' -> ['struct', 'XX']"""
            return typ[1:].split(".", maxsplit=1)

        type_map = (
            ## Type regex -> handler function
            (r"i[0-9]+", get_clisp_int_type),
            (r".*\*", get_clisp_ptr_type),
            (r"float|void", lambda typ: typ),
            (r"%struct\..*", get_clisp_struct_type),
        )
        if getattr(typ, "is_struct", False):
            # This is useful for global variable types (e.g. for typedefs), where
            # str(typ) looks like '%struct.XX = type { ... }'.
            # However, this test fails for struct types used in function parameters
            return typ.name.split(".")
        else:
            typ_str = str(typ)
            for pattern, handler in type_map:
                if re.fullmatch(pattern, typ_str):
                    return handler(typ_str)

        raise BindingGenError(f"Unknown type: {typ}")

    def gen_prototype(self, fn_ref):
        """Generate the prototype of fn_ref (LLVMLite ValueRef)"""
        # fn_ref is a function pointer; fn_type is the function's type
        fn_type = fn_ref.type.element_type
        type_elements = [self.get_clisp_type(elem) for elem in fn_type.elements]
        return [
            "define",
            [
                [fn_ref.name, type_elements[0]],
                *([f"arg-{t}", typ] for t, typ in enumerate(type_elements[1:])),
            ],
        ]

    def get_decl_ast(self, pattern):
        """
        Locate and return the first C AST node that has key values matching those in `pattern`.
        The node is assumed to be at the top level of the C program (e.g. functions, structs).
        """
        for decl in self.c_ast["inner"]:
            match = True
            for key, expected_val in pattern.items():
                if not decl.get(key) == expected_val:
                    match = False
            if match:
                return decl
        return None

    def gen_struct(self, struct_ref):
        """
        Generate a struct type corresponding to struct_ref (LLVMLite TypeRef).
        It is assumed that 'struct.`name`' in LLVM corresponds to the C declaration
        'struct `name` (...)', or 'typedef (...) `name`' if the former doesn't exist.
        Note that this only holds because of Clang's naming conventions.
        """
        assert struct_ref.name.startswith("struct.")
        struct_name = struct_ref.name.replace("struct.", "")

        # Get struct field types from the LLVM module
        field_types = [self.get_clisp_type(elem) for elem in struct_ref.elements]

        ## Get struct field names from the C AST, if possible
        # Search for the struct definition 'struct `struct_name`'
        struct_ast = self.get_decl_ast({"name": struct_name, "kind": "RecordDecl"})
        if struct_ast is None:
            # Search for 'typedef ... `struct_name`' and get the referenced struct AST
            typedef_ast = self.get_decl_ast(
                {"name": struct_name, "kind": "TypedefDecl"}
            )
            struct_ast_id = typedef_ast["inner"][0]["inner"][0]["decl"]["id"]
            struct_ast = self.get_decl_ast({"kind": "RecordDecl", "id": struct_ast_id})

        if struct_ast is None:
            # We can't determine the field names
            field_names = [f"field-{f}" for f in range(len(field_types))]
            debug_print(
                f"[WARNING] Cannot determine field names for '{struct_name}'; using 'field-0', 'field-1', ..."
            )
        else:
            field_names = []
            for field in struct_ast.get("inner", ()):
                if field["kind"] == "FieldDecl":
                    field_names.append(field["name"])
            assert len(field_names) == len(field_types)

        return [
            "define-struct",
            struct_name,
            *zip(field_names, field_types),
        ]

    def gen_typedef(self, alias):
        """Resolve the type that `alias` is typedef'ed to"""
        # The global variable of this type
        alias_var = self.llmod.get_global_variable(f"{VAR_PREFIX}{alias}")
        alias_type = self.get_clisp_type(alias_var.type.element_type)
        if self.debug:
            debug_print(f"Typedef: {alias} -> {alias_type}")
        return alias_type

    def build(self):
        tmpdir = tempfile.TemporaryDirectory()
        cprog = f"{tmpdir.name}/binding.c"
        llprog = f"{tmpdir.name}/binding.ll"

        # Generate C program that uses desired objects
        cprog_file = open(cprog, "w")
        cprog_str = self.gen_cprog()
        if self.debug:
            save_prog(cprog_str, "./binding.c")
        cprog_file.write(cprog_str)
        cprog_file.close()

        # Compile to LLVM and save the JSON AST dump
        res = subprocess.run(
            f"clang -I./ -o{llprog} -emit-llvm -S {cprog}".split(),
            capture_output=True,
            text=True,
        )
        if res.returncode != 0:
            raise BindingGenError(f"Compilation to LLVM IR by clang failed: {res.stderr}")
        res = subprocess.run(
            f"clang -I./ -Xclang -ast-dump=json -fsyntax-only {cprog}".split(),
            text=True,
            capture_output=True,
            check=True,
        )
        self.c_ast = json.loads(res.stdout)
        if self.debug:
            save_prog(res.stdout, "./binding.json")

        # Parse the LLVM IR and get a handle to the module
        llprog_file = open(llprog)
        llprog_str = llprog_file.read()
        if self.debug:
            save_prog(llprog_str, "./binding.ll")
        self.llmod = binding.parse_assembly(llprog_str)
        llprog_file.close()

        # Cleanup
        tmpdir.cleanup()

    def include(self):
        """
        Implementation of `include` macro
        """
        self.build()
        # Process all structs that are depended on, not just the desired ones
        struct_definitions = [
            self.gen_struct(struct) for struct in self.llmod.struct_types
        ]
        for name in self.typedefs:
            add_macro(name, self.gen_typedef(name), self.macro_ns)
        return [
            # Prototypes of desired functions
            *(
                self.gen_prototype(self.llmod.get_function(func))
                for func in self.functions
            ),
            # Struct type definitions
            *struct_definitions,
        ]


def include(headers, functions, structs, typedefs, debug=False, macro_ns=globals()):
    """
    Macro to include `functions` and `structs` from `headers`
    `debug` enables debug output
    `macro_ns` specifies the namespace into which macros should be added
    Example usage:
        ; Generates declarations for `malloc` and `puts`, having included stdio.h and stdlib.h
        ,(include (stdio.h stdlib.h) (malloc puts))
    """
    binding_generator = BindingGenerator(
        headers, functions, structs, typedefs, debug, macro_ns
    )
    return binding_generator.include()


# Utility functions
def save_prog(prog, path):
    f = open(path, "w")
    f.write(prog)
    f.close()


def add_macro(name, val, macro_ns):
    """Dynamically add a macro to `macro_ns` (typically this module)"""
    macro_ns[name] = val


def debug_print(self, *pargs, **kargs):
    assert "file" not in kargs
    print(*pargs, file=sys.stderr, **kargs)


if __name__ == "__main__":
    headers = input("Space-delimited list of headers to include: ").split()
    functions = input("Space-delimited list functions to parse: ").split()
    structs = input("Space-delimited list structs to parse: ").split()
    typedefs = input("Space-delimited list typedefs to parse: ").split()
    print(include(headers, functions, structs, typedefs, debug=True))
